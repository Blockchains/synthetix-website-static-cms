/**
 * Script to generate the local list of tokens
 */

"use strict";

const path = require("path");
const fs = require("fs");

const snx = require("synthetix");

const network = "mainnet";
const targets = snx.getTarget({ network });
const synths = snx.getSynths({ network });

const desc = synth => {
	const underlying = synth.desc.replace(/^Inverted /, "");
	const assetSuffix = synth.name !== underlying ? ` (${synth.asset})` : "";
	if (synth.name === "sUSD") {
		return `Tracks the price of a single US Dollar (USD). This Synth always remains constant at 1.`;
	} else if (synth.inverted) {
		// Note: indexes can be inverted - so we have this check earlier to show inverted info for inverted indexes
		const { entryPoint, upperLimit, lowerLimit } = synth.inverted;
		return (
			`Inversely tracks the price of ${underlying}${assetSuffix} through price feeds supplied by an oracle. ` +
			`The entry point is $${entryPoint} (the approximate market price at time of creation). ` +
			`This Synth freezes when it reaches its upper limit of $${upperLimit} (i.e. when ${underlying}'s ` +
			`value reaches $${lowerLimit}) or its lower limit of $${lowerLimit} (i.e. when ${underlying}â€™s value ` +
			`reaches $${upperLimit}). If it reaches either of its limits and gets frozen, it will no longer be ` +
			`able to be purchased on Synthetix.Exchange, but can still be traded for other Synths at its frozen ` +
			`value. At some point after it has reached either of its limits, it will be substituted for another ${
				synth.name
			} with different limits.`
		);
	} else if (synth.index) {
		return (
			`Tracks the price of the index: ${underlying}${assetSuffix} through price feeds supplied by an oracle. ` +
			`This index is made up of the following assets and weights: ` +
			synth.index
				.map(
					({ symbol, name, units }) =>
						`${units} of ${symbol}${name !== symbol ? ` (${name})` : ""}`
				)
				.join(", ") +
			"."
		);
	} else {
		return `Tracks the price of ${underlying}${assetSuffix} through price feeds supplied by an oracle.`;
	}
};

const tokens = [
	{
		symbol: "SNX",
		address: targets.ProxySynthetix.address,
		decimals: 18,
		description:
			"The Synthetix Network Token (SNX) gets staked as collateral to back Synths and entitles stakers to receive fees generated by Synth trades on Synthetix.Exchange."
	}
].concat(
	synths
		.filter(({ category }) => category !== "internal")
		.map(synth => ({
			symbol: synth.name,
			address: targets[`Proxy${synth.name}`].address,
			decimals: 18,
			description: desc(synth)
		}))
		.sort((a, b) => (a.symbol > b.symbol ? 1 : -1))
);

const output = {
	pageTitle: "Synthetix | Tokens",
	pageDescription:
		"Here you can access contract information about the various tokens in the Synthetix Network.",
	tokens
};

fs.writeFileSync(
	path.join(__dirname, "content", "pages", "tokens.json"),
	JSON.stringify(output, null, 2)
);
